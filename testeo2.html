<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrollytelling: Línea de Tiempo SVG</title>
    
    <style>
        /* --- ESTILOS CSS GENERALES Y DE LAYOUT --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f8f8;
        }

        /* Contenedor principal con Flexbox para dos columnas */
        .scrolly-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Panel fijo (el lado izquierdo con el SVG) */
        .sticky-panel {
            width: 40%;
            height: 100vh;
            position: sticky; /* ¡CLAVE! Mantiene el panel visible */
            top: 0;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Contenedor del texto (el lado derecho que se desplaza) */
        .scroll-narrative {
            width: 60%;
            padding-left: 40px;
        }
        
        /* Cada sección es larga para forzar el scroll */
        .scroll-narrative section {
            min-height: 150vh;
            padding: 20px 0;
            margin-bottom: 50px;
            border-left: 4px solid #ddd;
            padding-left: 20px;
        }

        /* --- ESTILOS CSS DEL SVG --- */
        #timeline-svg {
            width: 100%;
            height: 80%;
            overflow: visible; /* Asegura que el punto activo se vea fuera si es necesario */
        }

        /* La línea que se va a "dibujar" */
        .timeline-line {
            stroke: #007bff; /* Azul */
            stroke-width: 4;
            /* La transición CSS permite que el cambio de stroke-dashoffset sea suave */
            transition: stroke-dashoffset 1.5s ease-out; 
        }
        
        /* Los círculos que marcan los puntos */
        .timeline-point {
            fill: #333; /* Color inicial (inactivo) */
            transition: fill 0.5s ease-out, transform 0.5s ease-out;
            transform: scale(0.8); /* Tamaño inicial más pequeño */
        }
        
        /* Clase CSS para el punto activo (aplicada por JavaScript) */
        .point-active {
            fill: #dc3545; /* Color activo (Rojo) */
            transform: scale(1.2); /* Tamaño más grande para destacar */
        }
    </style>
</head>
<body>
    <div class="scrolly-container">
        <div class="sticky-panel">
            <svg id="timeline-svg" viewBox="0 0 100 600">
                
                <line id="main-line" class="timeline-line" x1="50" y1="10" x2="50" y2="590" />
                
                <circle id="point-1" class="timeline-point" cx="50" cy="100" r="10" data-index="1" />
                <circle id="point-2" class="timeline-point" cx="50" cy="300" r="10" data-index="2" />
                <circle id="point-3" class="timeline-point" cx="50" cy="500" r="10" data-index="3" />
            </svg>
        </div>

        <div class="scroll-narrative">
            <h1>Línea de Tiempo Interactiva</h1>
            <p>Desplázate hacia abajo para ver cómo se dibuja la línea.</p>
            
            <section class="step" data-state="1">
                <h2>Fase 1: El Comienzo (Primer Evento)</h2>
                <p>La línea comienza a animarse y el primer punto se ilumina, marcando el inicio de la secuencia de eventos. El 'Intersection Observer' detecta que esta sección es visible.</p>
                <p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p>
            </section>
            
            <section class="step" data-state="2">
                <h2>Fase 2: El Evento Intermedio</h2>
                <p>La narración avanza hasta el punto medio. La línea se extiende y el segundo punto de la línea de tiempo se resalta.</p>
                <p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p>
            </section>

            <section class="step" data-state="3">
                <h2>Fase 3: La Conclusión (Fin de la Línea)</h2>
                <p>La línea de tiempo se completa, revelando toda la historia. El tercer y último punto se activa.</p>
                <p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p><p>Texto de relleno...</p>
            </section>
            
            <div style="height: 50vh;"></div> </div>
    </div>
    
    <script>
        // --- CÓDIGO JAVASCRIPT ---
        
        // Seleccionamos todos los elementos necesarios
        const steps = document.querySelectorAll('.step');
        const mainLine = document.getElementById('main-line');
        const points = document.querySelectorAll('.timeline-point');

        // 1. CALCULAR Y OCULTAR LA LÍNEA
        
        // Función específica de SVG para obtener la longitud total de la línea
        const lineLength = mainLine.getTotalLength();

        // Ocultamos la línea al inicio, usando la técnica stroke-dasharray/offset
        mainLine.style.strokeDasharray = lineLength; 
        mainLine.style.strokeDashoffset = lineLength; // La línea está oculta

        // 2. CONFIGURACIÓN DEL OBSERVER
        const options = {
            root: null, // Observa el viewport
            rootMargin: '0px',
            threshold: 0.5 // Se activa cuando el 50% del elemento entra/sale de la vista
        };

        const observerCallback = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const stepIndex = parseInt(entry.target.dataset.state); // Obtiene el paso actual (1, 2 o 3)
                    
                    // --- A. ANIMAR EL DIBUJADO DE LA LÍNEA ---
                    let offsetTarget;
                    if (stepIndex === 1) {
                        offsetTarget = lineLength * (1 - (1/3)); // Dibuja 1/3
                    } else if (stepIndex === 2) {
                        offsetTarget = lineLength * (1 - (2/3)); // Dibuja 2/3
                    } else if (stepIndex === 3) {
                        offsetTarget = 0; // Dibuja el 100%
                    }
                    
                    // Aplicamos el nuevo offset (la transición CSS hace la animación)
                    mainLine.style.strokeDashoffset = offsetTarget;
                    
                    // --- B. ACTIVAR LOS PUNTOS ---
                    points.forEach(point => {
                        const pointIndex = parseInt(point.dataset.index);
                        
                        if (pointIndex <= stepIndex) {
                            // Activa el punto actual y los anteriores
                            point.classList.add('point-active');
                        } else {
                            // Desactiva los puntos posteriores
                            point.classList.remove('point-active');
                        }
                    });
                }
            });
        };

        // 3. CREAR Y ASIGNAR EL OBSERVER
        const observer = new IntersectionObserver(observerCallback, options);

        steps.forEach(step => {
            observer.observe(step);
        });
    </script>
</body>
</html>
